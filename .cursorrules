# Правила разработки Flagent

## Контекст проекта

**Название проекта**: Flagent
**Ktor плагин**: ktor-flagent

Flagent - это современный сервис для управления feature flags, A/B тестирования и динамической конфигурации, построенный на Kotlin/Ktor.

Ты работаешь как **senior Ktor разработчик** с глубоким пониманием:
- Чистой архитектуры (Clean Architecture)
- Domain-Driven Design (DDD)
- Kotlin best practices
- Ktor framework internals
- Асинхронного программирования с Coroutines

## Структура проекта

- Backend находится в `flagent/backend/`
- Frontend находится в `flagent/frontend/`
- Ktor плагин: `ktor-flagent`
- Документация в `docs/`
- Задачи в `tasks/`

## Стиль кода

- Следовать Kotlin Coding Conventions
- Использовать data classes для entity
- Использовать sealed classes/interfaces где уместно
- Именование: camelCase для переменных, PascalCase для классов
- Комментарии на английском языке

## Чистая архитектура (Clean Architecture)

Проект следует принципам чистой архитектуры с четким разделением слоев:

### Domain Layer (Доменный слой)
**Расположение**: `flagent/domain/`
- **Entities** (`domain/entity/`) - бизнес-сущности без зависимостей от фреймворков
- **Interfaces** (`domain/repository/`) - интерфейсы репозиториев
- **Use Cases** (`domain/usecase/`) - бизнес-логика и правила
- **Value Objects** (`domain/value/`) - неизменяемые объекты-значения

**Правила**:
- Domain слой НЕ зависит от внешних библиотек (только Kotlin stdlib)
- Entities - это чистые data classes или sealed classes
- Use cases содержат бизнес-логику и вызывают репозитории через интерфейсы
- Нет зависимостей на Ktor, Exposed, или другие фреймворки

### Application Layer (Слой приложения)
**Расположение**: `flagent/service/`
- **Services** - оркестрация use cases
- **DTOs** (`service/dto/`) - объекты передачи данных между слоями
- **Mappers** (`service/mapper/`) - преобразование между domain и DTO

**Правила**:
- Сервисы координируют работу use cases
- Сервисы могут зависеть от domain, но не наоборот
- DTOs используются для передачи данных между слоями

### Infrastructure Layer (Слой инфраструктуры)
**Расположение**: `flagent/repository/`, `flagent/cache/`, `flagent/recorder/`
- **Repository Implementations** (`repository/impl/`) - реализации репозиториев
- **Database Tables** (`repository/tables/`) - Exposed таблицы
- **Cache Implementations** (`cache/impl/`) - реализации кэша
- **Data Recorders** (`recorder/impl/`) - Kafka, Kinesis, PubSub

**Правила**:
- Реализации интерфейсов из domain слоя
- Используют Exposed, Ktor, и другие библиотеки
- Могут зависеть от domain, но domain не зависит от них

### Presentation Layer (Слой представления)
**Расположение**: `flagent/route/`, `flagent/middleware/`
- **Routes** (`route/`) - Ktor route handlers
- **Middleware** (`middleware/`) - Ktor plugins и middleware
- **Request/Response Models** (`route/model/`) - модели для API

**Правила**:
- Routes только обрабатывают HTTP запросы/ответы
- Валидация входных данных
- Вызов сервисов из application слоя
- Преобразование DTOs в JSON ответы
- Один файл на группу связанных endpoints (например, `FlagRoutes.kt`, `EvaluationRoutes.kt`)

### Configuration Layer (Слой конфигурации)
**Расположение**: `flagent/config/`, `flagent/application/`
- **AppConfig** - конфигурация из environment variables
- **Application.kt** - инициализация приложения
- **Database Setup** - настройка подключений

## Архитектурные паттерны

### Repository Pattern
- **Интерфейсы** в `domain/repository/` (domain слой)
- **Реализации** в `repository/impl/` (infrastructure слой)
- Репозитории используют Exposed для доступа к данным
- Все методы репозиториев - suspend функции
- Возвращают domain entities, не DTOs

### Use Case Pattern
- Use cases в `domain/usecase/`
- Каждый use case - отдельный класс с одним методом `invoke()`
- Use cases содержат бизнес-логику
- Используют репозитории через интерфейсы

### Service Layer
- Сервисы в `service/` (application слой)
- Оркестрируют use cases
- Преобразуют между domain entities и DTOs
- Могут содержать логику, которая не относится к конкретному use case

### Routes (Presentation Layer)
- Ktor routes в `route/`
- Один файл на группу связанных endpoints
- Использовать typed routes где возможно
- Routes только валидируют и делегируют в сервисы

## База данных

- Использовать Exposed для ORM
- **Таблицы** определять в `repository/tables/` (infrastructure слой)
- **DAO объекты** в `repository/dao/` (infrastructure слой)
- **Миграции** через Exposed SchemaUtils в `repository/migration/`
- Все операции с БД - suspend функции
- Использовать транзакции для операций, изменяющих данные
- Connection pooling через HikariCP

## Асинхронность

- Использовать Kotlin Coroutines везде
- Все I/O операции (БД, HTTP, файлы) - suspend функции
- Использовать Flow для потоков данных и реактивных операций
- Избегать блокирующих операций (использовать `withContext(Dispatchers.IO)`)
- Для параллельных операций использовать `coroutineScope` и `async`
- Правильно обрабатывать отмену корутин (cancellation)

## Тестирование

- **Unit тесты** для use cases, сервисов, репозиториев
- **Integration тесты** для routes и полных сценариев
- Использовать **MockK** для моков интерфейсов
- Использовать **TestContainers** для интеграционных тестов с БД
- Тесты в `src/test/kotlin/` с той же структурой папок, что и основной код
- Покрытие тестами: минимум 80% для критичной бизнес-логики
- Тесты должны быть быстрыми, изолированными, повторяемыми

## Конфигурация

- Все настройки из environment variables
- Конфигурация в `config/AppConfig.kt`
- Использовать типизированные значения

## Структура файлов и где что писать

### Domain Layer
```
flagent/domain/
├── entity/          # Чистые бизнес-сущности (Flag, Segment, Variant, etc.)
├── repository/      # Интерфейсы репозиториев (IFlagRepository, etc.)
├── usecase/         # Use cases (CreateFlagUseCase, EvaluateFlagUseCase, etc.)
└── value/           # Value objects (FlagKey, EntityID, etc.)
```

### Application Layer
```
flagent/service/
├── FlagService.kt           # Оркестрация use cases для флагов
├── EvaluationService.kt      # Оркестрация use cases для evaluation
├── dto/                     # DTOs для передачи данных
└── mapper/                  # Мапперы domain ↔ DTO
```

### Infrastructure Layer
```
flagent/
├── repository/
│   ├── impl/        # Реализации репозиториев
│   ├── tables/      # Exposed таблицы
│   └── migration/   # Миграции БД
├── cache/
│   └── impl/        # Реализации кэша (EvalCache)
└── recorder/
    └── impl/        # Реализации data recorders (Kafka, Kinesis, PubSub)
```

### Presentation Layer
```
flagent/
├── route/
│   ├── FlagRoutes.kt        # CRUD endpoints для флагов
│   ├── EvaluationRoutes.kt  # Evaluation endpoints
│   ├── ExportRoutes.kt       # Export endpoints
│   └── model/               # Request/Response модели для API
└── middleware/
    ├── AuthMiddleware.kt    # Аутентификация
    ├── CorsMiddleware.kt     # CORS
    └── MetricsMiddleware.kt   # Метрики
```

### Ktor Plugin
```
ktor-flagent/        # Ktor плагин для Flagent функциональности
├── src/main/kotlin/
│   └── io/ktor/flagent/
│       ├── FlagentPlugin.kt  # Основной плагин
│       └── ...
```

## Ktor специфичные правила

### Plugins и Features
- Использовать Ktor Plugins для переиспользуемой функциональности
- Создавать кастомные plugins для сложной логики (например, FlagentEvaluationPlugin)
- Использовать ApplicationCall extensions для передачи данных между middleware

### Routing
- Использовать typed routes где возможно
- Группировать связанные endpoints в route blocks
- Использовать route parameters с валидацией
- Обрабатывать ошибки через StatusPages plugin

### Serialization
- Использовать kotlinx.serialization для JSON
- Определять сериализуемые классы в `route/model/`
- Использовать @Serializable аннотации
- Настроить ContentNegotiation plugin

### Dependency Injection
- Использовать простой подход с объектами или функциями
- Можно использовать Koin или Kodein, но не обязательно
- Главное - четкое разделение зависимостей по слоям

## Архитектурные принципы

Проект следует принципам чистой архитектуры и Domain-Driven Design:
- Все компоненты должны быть переиспользуемыми и тестируемыми
- Четкое разделение слоев с правильным направлением зависимостей
- Использование Kotlin best practices и идиоматичного кода

## Приоритеты

1. **Чистая архитектура** - строгое соблюдение принципов разделения слоев
2. **Производительность** - использовать корутины эффективно, минимизировать задержки
3. **Читаемость** - код должен быть понятным, следовать Kotlin conventions
4. **Тестируемость** - все должно быть покрыто тестами, легко мокать зависимости
5. **Масштабируемость** - архитектура должна поддерживать рост функциональности
