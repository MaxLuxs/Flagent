/*
 * Flagent API
 * Flagent is a feature flagging, A/B testing and dynamic configuration microservice. The base path for all the APIs is \"/api/v1\". ## Authentication Flagent supports multiple authentication methods (configured via environment variables): - **JWT Authentication**: Bearer token authentication - **Basic Authentication**: Username/password authentication - **Header Authentication**: Custom header-based authentication - **Cookie Authentication**: Cookie-based authentication Some endpoints (like `/health`, `/evaluation`) may be whitelisted and don't require authentication. ## Error Responses All error responses follow the same format: ```json {   \"message\": \"Error description\" } ``` Common HTTP status codes: - `200`: Success - `400`: Bad Request - invalid input parameters - `404`: Not Found - resource doesn't exist - `429`: Too Many Requests - rate limit exceeded - `500`: Internal Server Error - server error ## Rate Limiting Rate limiting is configured via environment variables: - `FLAGENT_RATELIMITER_PERFLAG_PERSECOND_CONSOLE_LOGGING`: Maximum evaluations per flag per second (default: 100) When rate limit is exceeded, the API returns `429 Too Many Requests` status code. ## Best Practices - Use batch evaluation (`/evaluation/batch`) when evaluating multiple flags for multiple entities - Use `enableDebug: true` only in development environments - Preload flags with `preload=true` parameter when fetching flags to reduce subsequent API calls - Use tags to organize and filter flags efficiently 
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.flagent.client.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.jackson.nullable.JsonNullable;
import com.fasterxml.jackson.annotation.JsonIgnore;
import org.openapitools.jackson.nullable.JsonNullable;
import java.util.NoSuchElementException;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


import com.flagent.client.ApiClient;
/**
 * EvalContext
 */
@JsonPropertyOrder({
  EvalContext.JSON_PROPERTY_ENTITY_I_D,
  EvalContext.JSON_PROPERTY_ENTITY_TYPE,
  EvalContext.JSON_PROPERTY_ENTITY_CONTEXT,
  EvalContext.JSON_PROPERTY_ENABLE_DEBUG,
  EvalContext.JSON_PROPERTY_FLAG_I_D,
  EvalContext.JSON_PROPERTY_FLAG_KEY,
  EvalContext.JSON_PROPERTY_FLAG_TAGS,
  EvalContext.JSON_PROPERTY_FLAG_TAGS_OPERATOR
})
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.18.0")
public class EvalContext {
  public static final String JSON_PROPERTY_ENTITY_I_D = "entityID";
  @jakarta.annotation.Nullable
  private String entityID;

  public static final String JSON_PROPERTY_ENTITY_TYPE = "entityType";
  @jakarta.annotation.Nullable
  private String entityType;

  public static final String JSON_PROPERTY_ENTITY_CONTEXT = "entityContext";
  private JsonNullable<Map<String, Object>> entityContext = JsonNullable.<Map<String, Object>>undefined();

  public static final String JSON_PROPERTY_ENABLE_DEBUG = "enableDebug";
  @jakarta.annotation.Nullable
  private Boolean enableDebug = false;

  public static final String JSON_PROPERTY_FLAG_I_D = "flagID";
  private JsonNullable<Long> flagID = JsonNullable.<Long>undefined();

  public static final String JSON_PROPERTY_FLAG_KEY = "flagKey";
  private JsonNullable<String> flagKey = JsonNullable.<String>undefined();

  public static final String JSON_PROPERTY_FLAG_TAGS = "flagTags";
  private JsonNullable<List<String>> flagTags = JsonNullable.<List<String>>undefined();

  /**
   * Determine how flagTags is used to filter flags to be evaluated. OR extends the evaluation to those which contains at least one of the provided flagTags or AND limit the evaluation to those which contains all the flagTags.
   */
  public enum FlagTagsOperatorEnum {
    ANY(String.valueOf("ANY")),
    
    ALL(String.valueOf("ALL"));

    private String value;

    FlagTagsOperatorEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static FlagTagsOperatorEnum fromValue(String value) {
      for (FlagTagsOperatorEnum b : FlagTagsOperatorEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }
  }

  public static final String JSON_PROPERTY_FLAG_TAGS_OPERATOR = "flagTagsOperator";
  private JsonNullable<FlagTagsOperatorEnum> flagTagsOperator = JsonNullable.<FlagTagsOperatorEnum>of(FlagTagsOperatorEnum.ANY);

  public EvalContext() { 
  }

  public EvalContext entityID(@jakarta.annotation.Nullable String entityID) {
    this.entityID = entityID;
    return this;
  }

  /**
   * EntityID is used to deterministically at random to evaluate the flag result. If it&#39;s empty, Flagent will randomly generate one.
   * @return entityID
   */
  @jakarta.annotation.Nullable
  @JsonProperty(value = JSON_PROPERTY_ENTITY_I_D, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getEntityID() {
    return entityID;
  }


  @JsonProperty(value = JSON_PROPERTY_ENTITY_I_D, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setEntityID(@jakarta.annotation.Nullable String entityID) {
    this.entityID = entityID;
  }


  public EvalContext entityType(@jakarta.annotation.Nullable String entityType) {
    this.entityType = entityType;
    return this;
  }

  /**
   * Get entityType
   * @return entityType
   */
  @jakarta.annotation.Nullable
  @JsonProperty(value = JSON_PROPERTY_ENTITY_TYPE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getEntityType() {
    return entityType;
  }


  @JsonProperty(value = JSON_PROPERTY_ENTITY_TYPE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setEntityType(@jakarta.annotation.Nullable String entityType) {
    this.entityType = entityType;
  }


  public EvalContext entityContext(@jakarta.annotation.Nullable Map<String, Object> entityContext) {
    this.entityContext = JsonNullable.<Map<String, Object>>of(entityContext);
    return this;
  }

  public EvalContext putEntityContextItem(String key, Object entityContextItem) {
    if (this.entityContext == null || !this.entityContext.isPresent()) {
      this.entityContext = JsonNullable.<Map<String, Object>>of(new HashMap<>());
    }
    try {
      this.entityContext.get().put(key, entityContextItem);
    } catch (java.util.NoSuchElementException e) {
      // this can never happen, as we make sure above that the value is present
    }
    return this;
  }

  /**
   * Get entityContext
   * @return entityContext
   */
  @jakarta.annotation.Nullable
  @JsonIgnore
  public Map<String, Object> getEntityContext() {
        return entityContext.orElse(null);
  }

  @JsonProperty(value = JSON_PROPERTY_ENTITY_CONTEXT, required = false)
  @JsonInclude(content = JsonInclude.Include.ALWAYS, value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<Map<String, Object>> getEntityContext_JsonNullable() {
    return entityContext;
  }
  
  @JsonProperty(JSON_PROPERTY_ENTITY_CONTEXT)
  public void setEntityContext_JsonNullable(JsonNullable<Map<String, Object>> entityContext) {
    this.entityContext = entityContext;
  }

  public void setEntityContext(@jakarta.annotation.Nullable Map<String, Object> entityContext) {
    this.entityContext = JsonNullable.<Map<String, Object>>of(entityContext);
  }


  public EvalContext enableDebug(@jakarta.annotation.Nullable Boolean enableDebug) {
    this.enableDebug = enableDebug;
    return this;
  }

  /**
   * Get enableDebug
   * @return enableDebug
   */
  @jakarta.annotation.Nullable
  @JsonProperty(value = JSON_PROPERTY_ENABLE_DEBUG, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Boolean getEnableDebug() {
    return enableDebug;
  }


  @JsonProperty(value = JSON_PROPERTY_ENABLE_DEBUG, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setEnableDebug(@jakarta.annotation.Nullable Boolean enableDebug) {
    this.enableDebug = enableDebug;
  }


  public EvalContext flagID(@jakarta.annotation.Nullable Long flagID) {
    this.flagID = JsonNullable.<Long>of(flagID);
    return this;
  }

  /**
   * FlagID. flagID or flagKey will resolve to the same flag. Either works.
   * minimum: 1
   * @return flagID
   */
  @jakarta.annotation.Nullable
  @JsonIgnore
  public Long getFlagID() {
        return flagID.orElse(null);
  }

  @JsonProperty(value = JSON_PROPERTY_FLAG_I_D, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<Long> getFlagID_JsonNullable() {
    return flagID;
  }
  
  @JsonProperty(JSON_PROPERTY_FLAG_I_D)
  public void setFlagID_JsonNullable(JsonNullable<Long> flagID) {
    this.flagID = flagID;
  }

  public void setFlagID(@jakarta.annotation.Nullable Long flagID) {
    this.flagID = JsonNullable.<Long>of(flagID);
  }


  public EvalContext flagKey(@jakarta.annotation.Nullable String flagKey) {
    this.flagKey = JsonNullable.<String>of(flagKey);
    return this;
  }

  /**
   * FlagKey. flagID or flagKey will resolve to the same flag. Either works.
   * @return flagKey
   */
  @jakarta.annotation.Nullable
  @JsonIgnore
  public String getFlagKey() {
        return flagKey.orElse(null);
  }

  @JsonProperty(value = JSON_PROPERTY_FLAG_KEY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<String> getFlagKey_JsonNullable() {
    return flagKey;
  }
  
  @JsonProperty(JSON_PROPERTY_FLAG_KEY)
  public void setFlagKey_JsonNullable(JsonNullable<String> flagKey) {
    this.flagKey = flagKey;
  }

  public void setFlagKey(@jakarta.annotation.Nullable String flagKey) {
    this.flagKey = JsonNullable.<String>of(flagKey);
  }


  public EvalContext flagTags(@jakarta.annotation.Nullable List<String> flagTags) {
    this.flagTags = JsonNullable.<List<String>>of(flagTags);
    return this;
  }

  public EvalContext addFlagTagsItem(String flagTagsItem) {
    if (this.flagTags == null || !this.flagTags.isPresent()) {
      this.flagTags = JsonNullable.<List<String>>of(new ArrayList<>());
    }
    try {
      this.flagTags.get().add(flagTagsItem);
    } catch (java.util.NoSuchElementException e) {
      // this can never happen, as we make sure above that the value is present
    }
    return this;
  }

  /**
   * FlagTags. flagTags looks up flags by tag. Either works.
   * @return flagTags
   */
  @jakarta.annotation.Nullable
  @JsonIgnore
  public List<String> getFlagTags() {
        return flagTags.orElse(null);
  }

  @JsonProperty(value = JSON_PROPERTY_FLAG_TAGS, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<List<String>> getFlagTags_JsonNullable() {
    return flagTags;
  }
  
  @JsonProperty(JSON_PROPERTY_FLAG_TAGS)
  public void setFlagTags_JsonNullable(JsonNullable<List<String>> flagTags) {
    this.flagTags = flagTags;
  }

  public void setFlagTags(@jakarta.annotation.Nullable List<String> flagTags) {
    this.flagTags = JsonNullable.<List<String>>of(flagTags);
  }


  public EvalContext flagTagsOperator(@jakarta.annotation.Nullable FlagTagsOperatorEnum flagTagsOperator) {
    this.flagTagsOperator = JsonNullable.<FlagTagsOperatorEnum>of(flagTagsOperator);
    return this;
  }

  /**
   * Determine how flagTags is used to filter flags to be evaluated. OR extends the evaluation to those which contains at least one of the provided flagTags or AND limit the evaluation to those which contains all the flagTags.
   * @return flagTagsOperator
   */
  @jakarta.annotation.Nullable
  @JsonIgnore
  public FlagTagsOperatorEnum getFlagTagsOperator() {
        return flagTagsOperator.orElse(null);
  }

  @JsonProperty(value = JSON_PROPERTY_FLAG_TAGS_OPERATOR, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<FlagTagsOperatorEnum> getFlagTagsOperator_JsonNullable() {
    return flagTagsOperator;
  }
  
  @JsonProperty(JSON_PROPERTY_FLAG_TAGS_OPERATOR)
  public void setFlagTagsOperator_JsonNullable(JsonNullable<FlagTagsOperatorEnum> flagTagsOperator) {
    this.flagTagsOperator = flagTagsOperator;
  }

  public void setFlagTagsOperator(@jakarta.annotation.Nullable FlagTagsOperatorEnum flagTagsOperator) {
    this.flagTagsOperator = JsonNullable.<FlagTagsOperatorEnum>of(flagTagsOperator);
  }


  /**
   * Return true if this EvalContext object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EvalContext evalContext = (EvalContext) o;
    return Objects.equals(this.entityID, evalContext.entityID) &&
        Objects.equals(this.entityType, evalContext.entityType) &&
        equalsNullable(this.entityContext, evalContext.entityContext) &&
        Objects.equals(this.enableDebug, evalContext.enableDebug) &&
        equalsNullable(this.flagID, evalContext.flagID) &&
        equalsNullable(this.flagKey, evalContext.flagKey) &&
        equalsNullable(this.flagTags, evalContext.flagTags) &&
        equalsNullable(this.flagTagsOperator, evalContext.flagTagsOperator);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(entityID, entityType, hashCodeNullable(entityContext), enableDebug, hashCodeNullable(flagID), hashCodeNullable(flagKey), hashCodeNullable(flagTags), hashCodeNullable(flagTagsOperator));
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class EvalContext {\n");
    sb.append("    entityID: ").append(toIndentedString(entityID)).append("\n");
    sb.append("    entityType: ").append(toIndentedString(entityType)).append("\n");
    sb.append("    entityContext: ").append(toIndentedString(entityContext)).append("\n");
    sb.append("    enableDebug: ").append(toIndentedString(enableDebug)).append("\n");
    sb.append("    flagID: ").append(toIndentedString(flagID)).append("\n");
    sb.append("    flagKey: ").append(toIndentedString(flagKey)).append("\n");
    sb.append("    flagTags: ").append(toIndentedString(flagTags)).append("\n");
    sb.append("    flagTagsOperator: ").append(toIndentedString(flagTagsOperator)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `entityID` to the URL query string
    if (getEntityID() != null) {
      joiner.add(String.format(java.util.Locale.ROOT, "%sentityID%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getEntityID()))));
    }

    // add `entityType` to the URL query string
    if (getEntityType() != null) {
      joiner.add(String.format(java.util.Locale.ROOT, "%sentityType%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getEntityType()))));
    }

    // add `entityContext` to the URL query string
    if (getEntityContext() != null) {
      for (String _key : getEntityContext().keySet()) {
        joiner.add(String.format(java.util.Locale.ROOT, "%sentityContext%s%s=%s", prefix, suffix,
            "".equals(suffix) ? "" : String.format(java.util.Locale.ROOT, "%s%d%s", containerPrefix, _key, containerSuffix),
            getEntityContext().get(_key), ApiClient.urlEncode(ApiClient.valueToString(getEntityContext().get(_key)))));
      }
    }

    // add `enableDebug` to the URL query string
    if (getEnableDebug() != null) {
      joiner.add(String.format(java.util.Locale.ROOT, "%senableDebug%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getEnableDebug()))));
    }

    // add `flagID` to the URL query string
    if (getFlagID() != null) {
      joiner.add(String.format(java.util.Locale.ROOT, "%sflagID%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getFlagID()))));
    }

    // add `flagKey` to the URL query string
    if (getFlagKey() != null) {
      joiner.add(String.format(java.util.Locale.ROOT, "%sflagKey%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getFlagKey()))));
    }

    // add `flagTags` to the URL query string
    if (getFlagTags() != null) {
      for (int i = 0; i < getFlagTags().size(); i++) {
        joiner.add(String.format(java.util.Locale.ROOT, "%sflagTags%s%s=%s", prefix, suffix,
            "".equals(suffix) ? "" : String.format(java.util.Locale.ROOT, "%s%d%s", containerPrefix, i, containerSuffix),
            ApiClient.urlEncode(ApiClient.valueToString(getFlagTags().get(i)))));
      }
    }

    // add `flagTagsOperator` to the URL query string
    if (getFlagTagsOperator() != null) {
      joiner.add(String.format(java.util.Locale.ROOT, "%sflagTagsOperator%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getFlagTagsOperator()))));
    }

    return joiner.toString();
  }
}

