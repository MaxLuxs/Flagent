# coding: utf-8

"""
    Flagent API

    Flagent is a feature flagging, A/B testing and dynamic configuration microservice. The base path for all the APIs is \"/api/v1\". ## Authentication Flagent supports multiple authentication methods (configured via environment variables): - **JWT Authentication**: Bearer token authentication - **Basic Authentication**: Username/password authentication - **Header Authentication**: Custom header-based authentication - **Cookie Authentication**: Cookie-based authentication Some endpoints (like `/health`, `/evaluation`) may be whitelisted and don't require authentication. ## Error Responses All error responses follow the same format: ```json {   \"message\": \"Error description\" } ``` Common HTTP status codes: - `200`: Success - `400`: Bad Request - invalid input parameters - `404`: Not Found - resource doesn't exist - `429`: Too Many Requests - rate limit exceeded - `500`: Internal Server Error - server error ## Rate Limiting Rate limiting is configured via environment variables: - `FLAGENT_RATELIMITER_PERFLAG_PERSECOND_CONSOLE_LOGGING`: Maximum evaluations per flag per second (default: 100) When rate limit is exceeded, the API returns `429 Too Many Requests` status code. ## Best Practices - Use batch evaluation (`/evaluation/batch`) when evaluating multiple flags for multiple entities - Use `enableDebug: true` only in development environments - Preload flags with `preload=true` parameter when fetching flags to reduce subsequent API calls - Use tags to organize and filter flags efficiently 

    The version of the OpenAPI document: 0.1.6
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class EvalContext(BaseModel):
    """
    EvalContext
    """ # noqa: E501
    entity_id: Optional[StrictStr] = Field(default=None, description="EntityID is used to deterministically at random to evaluate the flag result. If it's empty, Flagent will randomly generate one.", alias="entityID")
    entity_type: Optional[StrictStr] = Field(default=None, alias="entityType")
    entity_context: Optional[Dict[str, Any]] = Field(default=None, alias="entityContext")
    enable_debug: Optional[StrictBool] = Field(default=False, alias="enableDebug")
    flag_id: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=None, description="FlagID. flagID or flagKey will resolve to the same flag. Either works.", alias="flagID")
    flag_key: Optional[StrictStr] = Field(default=None, description="FlagKey. flagID or flagKey will resolve to the same flag. Either works.", alias="flagKey")
    flag_tags: Optional[List[StrictStr]] = Field(default=None, description="FlagTags. flagTags looks up flags by tag. Either works.", alias="flagTags")
    flag_tags_operator: Optional[StrictStr] = Field(default='ANY', description="Determine how flagTags is used to filter flags to be evaluated. OR extends the evaluation to those which contains at least one of the provided flagTags or AND limit the evaluation to those which contains all the flagTags.", alias="flagTagsOperator")
    __properties: ClassVar[List[str]] = ["entityID", "entityType", "entityContext", "enableDebug", "flagID", "flagKey", "flagTags", "flagTagsOperator"]

    @field_validator('flag_tags_operator')
    def flag_tags_operator_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['ANY', 'ALL']):
            raise ValueError("must be one of enum values ('ANY', 'ALL')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of EvalContext from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if entity_context (nullable) is None
        # and model_fields_set contains the field
        if self.entity_context is None and "entity_context" in self.model_fields_set:
            _dict['entityContext'] = None

        # set to None if flag_id (nullable) is None
        # and model_fields_set contains the field
        if self.flag_id is None and "flag_id" in self.model_fields_set:
            _dict['flagID'] = None

        # set to None if flag_key (nullable) is None
        # and model_fields_set contains the field
        if self.flag_key is None and "flag_key" in self.model_fields_set:
            _dict['flagKey'] = None

        # set to None if flag_tags (nullable) is None
        # and model_fields_set contains the field
        if self.flag_tags is None and "flag_tags" in self.model_fields_set:
            _dict['flagTags'] = None

        # set to None if flag_tags_operator (nullable) is None
        # and model_fields_set contains the field
        if self.flag_tags_operator is None and "flag_tags_operator" in self.model_fields_set:
            _dict['flagTagsOperator'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of EvalContext from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "entityID": obj.get("entityID"),
            "entityType": obj.get("entityType"),
            "entityContext": obj.get("entityContext"),
            "enableDebug": obj.get("enableDebug") if obj.get("enableDebug") is not None else False,
            "flagID": obj.get("flagID"),
            "flagKey": obj.get("flagKey"),
            "flagTags": obj.get("flagTags"),
            "flagTagsOperator": obj.get("flagTagsOperator") if obj.get("flagTagsOperator") is not None else 'ANY'
        })
        return _obj


