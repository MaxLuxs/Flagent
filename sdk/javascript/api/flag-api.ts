/* tslint:disable */
/* eslint-disable */
/**
 * Flagent API
 * Flagent is a feature flagging, A/B testing and dynamic configuration microservice. The base path for all the APIs is \"/api/v1\". ## Authentication Flagent supports multiple authentication methods (configured via environment variables): - **JWT Authentication**: Bearer token authentication - **Basic Authentication**: Username/password authentication - **Header Authentication**: Custom header-based authentication - **Cookie Authentication**: Cookie-based authentication Some endpoints (like `/health`, `/evaluation`) may be whitelisted and don\'t require authentication. ## Error Responses All error responses follow the same format: ```json {   \"message\": \"Error description\" } ``` Common HTTP status codes: - `200`: Success - `400`: Bad Request - invalid input parameters - `404`: Not Found - resource doesn\'t exist - `429`: Too Many Requests - rate limit exceeded - `500`: Internal Server Error - server error ## Rate Limiting Rate limiting is configured via environment variables: - `FLAGENT_RATELIMITER_PERFLAG_PERSECOND_CONSOLE_LOGGING`: Maximum evaluations per flag per second (default: 100) When rate limit is exceeded, the API returns `429 Too Many Requests` status code. ## Best Practices - Use batch evaluation (`/evaluation/batch`) when evaluating multiple flags for multiple entities - Use `enableDebug: true` only in development environments - Preload flags with `preload=true` parameter when fetching flags to reduce subsequent API calls - Use tags to organize and filter flags efficiently 
 *
 * The version of the OpenAPI document: 1.1.19
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { CreateFlagRequest } from '../models';
// @ts-ignore
import type { Flag } from '../models';
// @ts-ignore
import type { FlagSnapshot } from '../models';
// @ts-ignore
import type { PutFlagRequest } from '../models';
// @ts-ignore
import type { SetFlagEnabledRequest } from '../models';
/**
 * FlagApi - axios parameter creator
 */
export const FlagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new flag
         * @param {CreateFlagRequest} createFlagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlag: async (createFlagRequest: CreateFlagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFlagRequest' is not null or undefined
            assertParamExists('createFlag', 'createFlagRequest', createFlagRequest)
            const localVarPath = `/flags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFlagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete flag
         * @param {number} flagId Numeric ID of the flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlag: async (flagId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flagId' is not null or undefined
            assertParamExists('deleteFlag', 'flagId', flagId)
            const localVarPath = `/flags/{flagId}`
                .replace(`{${"flagId"}}`, encodeURIComponent(String(flagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all flags
         * @param {number} [limit] The numbers of flags to return
         * @param {number} [offset] Return flags given the offset, it should usually set together with limit
         * @param {boolean} [enabled] Return flags having given enabled status
         * @param {string} [description] Filter flags by exact description match
         * @param {string} [key] Filter flags by exact key match
         * @param {string} [descriptionLike] Filter flags by partial description match
         * @param {boolean} [preload] Preload segments, variants, and tags
         * @param {boolean} [deleted] Include deleted flags in results
         * @param {string} [tags] Filter flags by tags (comma-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFlags: async (limit?: number, offset?: number, enabled?: boolean, description?: string, key?: string, descriptionLike?: string, preload?: boolean, deleted?: boolean, tags?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/flags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (descriptionLike !== undefined) {
                localVarQueryParameter['descriptionLike'] = descriptionLike;
            }

            if (preload !== undefined) {
                localVarQueryParameter['preload'] = preload;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get flag by ID
         * @param {number} flagId Numeric ID of the flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlag: async (flagId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flagId' is not null or undefined
            assertParamExists('getFlag', 'flagId', flagId)
            const localVarPath = `/flags/{flagId}`
                .replace(`{${"flagId"}}`, encodeURIComponent(String(flagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all entity types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagEntityTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/flags/entity_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get flag snapshots
         * @param {number} flagId Numeric ID of the flag
         * @param {number} [limit] The number of snapshots to return
         * @param {number} [offset] Return snapshots given the offset
         * @param {GetFlagSnapshotsSortEnum} [sort] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagSnapshots: async (flagId: number, limit?: number, offset?: number, sort?: GetFlagSnapshotsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flagId' is not null or undefined
            assertParamExists('getFlagSnapshots', 'flagId', flagId)
            const localVarPath = `/flags/{flagId}/snapshots`
                .replace(`{${"flagId"}}`, encodeURIComponent(String(flagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update flag
         * @param {number} flagId Numeric ID of the flag
         * @param {PutFlagRequest} putFlagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFlag: async (flagId: number, putFlagRequest: PutFlagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flagId' is not null or undefined
            assertParamExists('putFlag', 'flagId', flagId)
            // verify required parameter 'putFlagRequest' is not null or undefined
            assertParamExists('putFlag', 'putFlagRequest', putFlagRequest)
            const localVarPath = `/flags/{flagId}`
                .replace(`{${"flagId"}}`, encodeURIComponent(String(flagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putFlagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore deleted flag
         * @param {number} flagId Numeric ID of the flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreFlag: async (flagId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flagId' is not null or undefined
            assertParamExists('restoreFlag', 'flagId', flagId)
            const localVarPath = `/flags/{flagId}/restore`
                .replace(`{${"flagId"}}`, encodeURIComponent(String(flagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set flag enabled status
         * @param {number} flagId Numeric ID of the flag
         * @param {SetFlagEnabledRequest} setFlagEnabledRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFlagEnabled: async (flagId: number, setFlagEnabledRequest: SetFlagEnabledRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flagId' is not null or undefined
            assertParamExists('setFlagEnabled', 'flagId', flagId)
            // verify required parameter 'setFlagEnabledRequest' is not null or undefined
            assertParamExists('setFlagEnabled', 'setFlagEnabledRequest', setFlagEnabledRequest)
            const localVarPath = `/flags/{flagId}/enabled`
                .replace(`{${"flagId"}}`, encodeURIComponent(String(flagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setFlagEnabledRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlagApi - functional programming interface
 */
export const FlagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new flag
         * @param {CreateFlagRequest} createFlagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFlag(createFlagRequest: CreateFlagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFlag(createFlagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlagApi.createFlag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete flag
         * @param {number} flagId Numeric ID of the flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFlag(flagId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFlag(flagId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlagApi.deleteFlag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all flags
         * @param {number} [limit] The numbers of flags to return
         * @param {number} [offset] Return flags given the offset, it should usually set together with limit
         * @param {boolean} [enabled] Return flags having given enabled status
         * @param {string} [description] Filter flags by exact description match
         * @param {string} [key] Filter flags by exact key match
         * @param {string} [descriptionLike] Filter flags by partial description match
         * @param {boolean} [preload] Preload segments, variants, and tags
         * @param {boolean} [deleted] Include deleted flags in results
         * @param {string} [tags] Filter flags by tags (comma-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findFlags(limit?: number, offset?: number, enabled?: boolean, description?: string, key?: string, descriptionLike?: string, preload?: boolean, deleted?: boolean, tags?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Flag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findFlags(limit, offset, enabled, description, key, descriptionLike, preload, deleted, tags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlagApi.findFlags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get flag by ID
         * @param {number} flagId Numeric ID of the flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlag(flagId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlag(flagId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlagApi.getFlag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all entity types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlagEntityTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlagEntityTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlagApi.getFlagEntityTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get flag snapshots
         * @param {number} flagId Numeric ID of the flag
         * @param {number} [limit] The number of snapshots to return
         * @param {number} [offset] Return snapshots given the offset
         * @param {GetFlagSnapshotsSortEnum} [sort] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlagSnapshots(flagId: number, limit?: number, offset?: number, sort?: GetFlagSnapshotsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlagSnapshot>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlagSnapshots(flagId, limit, offset, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlagApi.getFlagSnapshots']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update flag
         * @param {number} flagId Numeric ID of the flag
         * @param {PutFlagRequest} putFlagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFlag(flagId: number, putFlagRequest: PutFlagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFlag(flagId, putFlagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlagApi.putFlag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Restore deleted flag
         * @param {number} flagId Numeric ID of the flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreFlag(flagId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreFlag(flagId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlagApi.restoreFlag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set flag enabled status
         * @param {number} flagId Numeric ID of the flag
         * @param {SetFlagEnabledRequest} setFlagEnabledRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setFlagEnabled(flagId: number, setFlagEnabledRequest: SetFlagEnabledRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setFlagEnabled(flagId, setFlagEnabledRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlagApi.setFlagEnabled']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FlagApi - factory interface
 */
export const FlagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlagApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new flag
         * @param {CreateFlagRequest} createFlagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlag(createFlagRequest: CreateFlagRequest, options?: RawAxiosRequestConfig): AxiosPromise<Flag> {
            return localVarFp.createFlag(createFlagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete flag
         * @param {number} flagId Numeric ID of the flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlag(flagId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFlag(flagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all flags
         * @param {number} [limit] The numbers of flags to return
         * @param {number} [offset] Return flags given the offset, it should usually set together with limit
         * @param {boolean} [enabled] Return flags having given enabled status
         * @param {string} [description] Filter flags by exact description match
         * @param {string} [key] Filter flags by exact key match
         * @param {string} [descriptionLike] Filter flags by partial description match
         * @param {boolean} [preload] Preload segments, variants, and tags
         * @param {boolean} [deleted] Include deleted flags in results
         * @param {string} [tags] Filter flags by tags (comma-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFlags(limit?: number, offset?: number, enabled?: boolean, description?: string, key?: string, descriptionLike?: string, preload?: boolean, deleted?: boolean, tags?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Flag>> {
            return localVarFp.findFlags(limit, offset, enabled, description, key, descriptionLike, preload, deleted, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get flag by ID
         * @param {number} flagId Numeric ID of the flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlag(flagId: number, options?: RawAxiosRequestConfig): AxiosPromise<Flag> {
            return localVarFp.getFlag(flagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all entity types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagEntityTypes(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getFlagEntityTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get flag snapshots
         * @param {number} flagId Numeric ID of the flag
         * @param {number} [limit] The number of snapshots to return
         * @param {number} [offset] Return snapshots given the offset
         * @param {GetFlagSnapshotsSortEnum} [sort] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagSnapshots(flagId: number, limit?: number, offset?: number, sort?: GetFlagSnapshotsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlagSnapshot>> {
            return localVarFp.getFlagSnapshots(flagId, limit, offset, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update flag
         * @param {number} flagId Numeric ID of the flag
         * @param {PutFlagRequest} putFlagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFlag(flagId: number, putFlagRequest: PutFlagRequest, options?: RawAxiosRequestConfig): AxiosPromise<Flag> {
            return localVarFp.putFlag(flagId, putFlagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore deleted flag
         * @param {number} flagId Numeric ID of the flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreFlag(flagId: number, options?: RawAxiosRequestConfig): AxiosPromise<Flag> {
            return localVarFp.restoreFlag(flagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set flag enabled status
         * @param {number} flagId Numeric ID of the flag
         * @param {SetFlagEnabledRequest} setFlagEnabledRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFlagEnabled(flagId: number, setFlagEnabledRequest: SetFlagEnabledRequest, options?: RawAxiosRequestConfig): AxiosPromise<Flag> {
            return localVarFp.setFlagEnabled(flagId, setFlagEnabledRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlagApi - interface
 */
export interface FlagApiInterface {
    /**
     * 
     * @summary Create a new flag
     * @param {CreateFlagRequest} createFlagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFlag(createFlagRequest: CreateFlagRequest, options?: RawAxiosRequestConfig): AxiosPromise<Flag>;

    /**
     * 
     * @summary Delete flag
     * @param {number} flagId Numeric ID of the flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFlag(flagId: number, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get all flags
     * @param {number} [limit] The numbers of flags to return
     * @param {number} [offset] Return flags given the offset, it should usually set together with limit
     * @param {boolean} [enabled] Return flags having given enabled status
     * @param {string} [description] Filter flags by exact description match
     * @param {string} [key] Filter flags by exact key match
     * @param {string} [descriptionLike] Filter flags by partial description match
     * @param {boolean} [preload] Preload segments, variants, and tags
     * @param {boolean} [deleted] Include deleted flags in results
     * @param {string} [tags] Filter flags by tags (comma-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findFlags(limit?: number, offset?: number, enabled?: boolean, description?: string, key?: string, descriptionLike?: string, preload?: boolean, deleted?: boolean, tags?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Flag>>;

    /**
     * 
     * @summary Get flag by ID
     * @param {number} flagId Numeric ID of the flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFlag(flagId: number, options?: RawAxiosRequestConfig): AxiosPromise<Flag>;

    /**
     * 
     * @summary Get all entity types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFlagEntityTypes(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>>;

    /**
     * 
     * @summary Get flag snapshots
     * @param {number} flagId Numeric ID of the flag
     * @param {number} [limit] The number of snapshots to return
     * @param {number} [offset] Return snapshots given the offset
     * @param {GetFlagSnapshotsSortEnum} [sort] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFlagSnapshots(flagId: number, limit?: number, offset?: number, sort?: GetFlagSnapshotsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlagSnapshot>>;

    /**
     * 
     * @summary Update flag
     * @param {number} flagId Numeric ID of the flag
     * @param {PutFlagRequest} putFlagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putFlag(flagId: number, putFlagRequest: PutFlagRequest, options?: RawAxiosRequestConfig): AxiosPromise<Flag>;

    /**
     * 
     * @summary Restore deleted flag
     * @param {number} flagId Numeric ID of the flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreFlag(flagId: number, options?: RawAxiosRequestConfig): AxiosPromise<Flag>;

    /**
     * 
     * @summary Set flag enabled status
     * @param {number} flagId Numeric ID of the flag
     * @param {SetFlagEnabledRequest} setFlagEnabledRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFlagEnabled(flagId: number, setFlagEnabledRequest: SetFlagEnabledRequest, options?: RawAxiosRequestConfig): AxiosPromise<Flag>;

}

/**
 * FlagApi - object-oriented interface
 */
export class FlagApi extends BaseAPI implements FlagApiInterface {
    /**
     * 
     * @summary Create a new flag
     * @param {CreateFlagRequest} createFlagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFlag(createFlagRequest: CreateFlagRequest, options?: RawAxiosRequestConfig) {
        return FlagApiFp(this.configuration).createFlag(createFlagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete flag
     * @param {number} flagId Numeric ID of the flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFlag(flagId: number, options?: RawAxiosRequestConfig) {
        return FlagApiFp(this.configuration).deleteFlag(flagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all flags
     * @param {number} [limit] The numbers of flags to return
     * @param {number} [offset] Return flags given the offset, it should usually set together with limit
     * @param {boolean} [enabled] Return flags having given enabled status
     * @param {string} [description] Filter flags by exact description match
     * @param {string} [key] Filter flags by exact key match
     * @param {string} [descriptionLike] Filter flags by partial description match
     * @param {boolean} [preload] Preload segments, variants, and tags
     * @param {boolean} [deleted] Include deleted flags in results
     * @param {string} [tags] Filter flags by tags (comma-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findFlags(limit?: number, offset?: number, enabled?: boolean, description?: string, key?: string, descriptionLike?: string, preload?: boolean, deleted?: boolean, tags?: string, options?: RawAxiosRequestConfig) {
        return FlagApiFp(this.configuration).findFlags(limit, offset, enabled, description, key, descriptionLike, preload, deleted, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get flag by ID
     * @param {number} flagId Numeric ID of the flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFlag(flagId: number, options?: RawAxiosRequestConfig) {
        return FlagApiFp(this.configuration).getFlag(flagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all entity types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFlagEntityTypes(options?: RawAxiosRequestConfig) {
        return FlagApiFp(this.configuration).getFlagEntityTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get flag snapshots
     * @param {number} flagId Numeric ID of the flag
     * @param {number} [limit] The number of snapshots to return
     * @param {number} [offset] Return snapshots given the offset
     * @param {GetFlagSnapshotsSortEnum} [sort] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFlagSnapshots(flagId: number, limit?: number, offset?: number, sort?: GetFlagSnapshotsSortEnum, options?: RawAxiosRequestConfig) {
        return FlagApiFp(this.configuration).getFlagSnapshots(flagId, limit, offset, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update flag
     * @param {number} flagId Numeric ID of the flag
     * @param {PutFlagRequest} putFlagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putFlag(flagId: number, putFlagRequest: PutFlagRequest, options?: RawAxiosRequestConfig) {
        return FlagApiFp(this.configuration).putFlag(flagId, putFlagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore deleted flag
     * @param {number} flagId Numeric ID of the flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public restoreFlag(flagId: number, options?: RawAxiosRequestConfig) {
        return FlagApiFp(this.configuration).restoreFlag(flagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set flag enabled status
     * @param {number} flagId Numeric ID of the flag
     * @param {SetFlagEnabledRequest} setFlagEnabledRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setFlagEnabled(flagId: number, setFlagEnabledRequest: SetFlagEnabledRequest, options?: RawAxiosRequestConfig) {
        return FlagApiFp(this.configuration).setFlagEnabled(flagId, setFlagEnabledRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetFlagSnapshotsSortEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type GetFlagSnapshotsSortEnum = typeof GetFlagSnapshotsSortEnum[keyof typeof GetFlagSnapshotsSortEnum];
