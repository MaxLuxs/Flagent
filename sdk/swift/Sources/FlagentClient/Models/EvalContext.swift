//
// EvalContext.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct EvalContext: Codable, JSONEncodable, Hashable {

    public enum FlagTagsOperator: String, Codable, CaseIterable {
        case any = "ANY"
        case all = "ALL"
    }
    public static let flagIDRule = NumericRule<Int64>(minimum: 1, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    /** EntityID is used to deterministically at random to evaluate the flag result. If it's empty, Flagent will randomly generate one. */
    public var entityID: String?
    public var entityType: String?
    public var entityContext: [String: AnyCodable]?
    public var enableDebug: Bool? = false
    /** FlagID. flagID or flagKey will resolve to the same flag. Either works. */
    public var flagID: Int64?
    /** FlagKey. flagID or flagKey will resolve to the same flag. Either works. */
    public var flagKey: String?
    /** FlagTags. flagTags looks up flags by tag. Either works. */
    public var flagTags: [String]?
    /** Determine how flagTags is used to filter flags to be evaluated. OR extends the evaluation to those which contains at least one of the provided flagTags or AND limit the evaluation to those which contains all the flagTags. */
    public var flagTagsOperator: FlagTagsOperator? = .any

    public init(entityID: String? = nil, entityType: String? = nil, entityContext: [String: AnyCodable]? = nil, enableDebug: Bool? = false, flagID: Int64? = nil, flagKey: String? = nil, flagTags: [String]? = nil, flagTagsOperator: FlagTagsOperator? = .any) {
        self.entityID = entityID
        self.entityType = entityType
        self.entityContext = entityContext
        self.enableDebug = enableDebug
        self.flagID = flagID
        self.flagKey = flagKey
        self.flagTags = flagTags
        self.flagTagsOperator = flagTagsOperator
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case entityID
        case entityType
        case entityContext
        case enableDebug
        case flagID
        case flagKey
        case flagTags
        case flagTagsOperator
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(entityID, forKey: .entityID)
        try container.encodeIfPresent(entityType, forKey: .entityType)
        try container.encodeIfPresent(entityContext, forKey: .entityContext)
        try container.encodeIfPresent(enableDebug, forKey: .enableDebug)
        try container.encodeIfPresent(flagID, forKey: .flagID)
        try container.encodeIfPresent(flagKey, forKey: .flagKey)
        try container.encodeIfPresent(flagTags, forKey: .flagTags)
        try container.encodeIfPresent(flagTagsOperator, forKey: .flagTagsOperator)
    }
}

