# Спецификация evaluation Flagent

> [English](evaluation-spec.md) | Русский

Каноническая спецификация для evaluation флагов, rollout и проверки ограничений. Все реализации (backend, shared evaluator, Kotlin/Go Enhanced SDK) должны следовать этой спецификации для одинаковых результатов.

## 1. Вход для хеша (rollout)

- **Порядок:** `salt + entityID` (без разделителя)
- **Кодировка:** UTF-8 байты
- **Salt:** обычно ID флага как строка (например `flag.id.toString()`)

Пример: `salt = "1"`, `entityID = "user_123"` → вход = `"1user_123"`.

## 2. CRC32

- **Алгоритм:** стандартный CRC-32 (полином 0xEDB88320)
- **Вход:** байтовый массив строки (UTF-8)
- **Выход:** 32-битное беззнаковое целое
- **Использование:** `bucket = crc32(salt + entityID) % 1000` (bucket в 0..999)

Реализация на чистом Kotlin (без `java.util.zip.CRC32`) — см. [English version](evaluation-spec.md#2-crc32).

## 3. Bucket и rollout

- **Всего корзин:** 1000 (0..999)
- **Bucket:** `crc32((salt + entityID).toByteArray()) % 1000`
- **Процент rollout:** 0–100
- **Порог:** entity в rollout тогда и только тогда, когда `bucket < rolloutThreshold`, где `rolloutThreshold = rolloutPercent * 10` (например 50% → 500)

## 4. Распределение (выбор варианта)

Накопленные проценты по вариантам (p1*10, p1*10+p2*10, …, 1000). Индекс варианта — двоичный поиск по накопленным процентам с использованием `bucket + 1` (1..1000). Формула: `bucketInt = (bucket % 1000) + 1`; найти индекс i такой, что `accumulated[i-1] < bucketInt <= accumulated[i]`; вернуть `variantIds[i]`.

## 5. Операторы ограничений

Поддерживаемые операторы для ограничений сегментов: EQ, NEQ, LT, LTE, GT, GTE, EREG, NEREG, IN, NOTIN, CONTAINS, NOTCONTAINS. Значение из `entityContext` сравнивается со значением ограничения как строка (для LT/LTE/GT/GTE — числовое сравнение). Полная таблица — в [English version](evaluation-spec.md#5-constraint-operators).

## 6. Порядок evaluation

1. Найти флаг (по ID или key).
2. Если флаг выключен или нет сегментов → вернуть «нет варианта».
3. Сортировать сегменты по `rank` по возрастанию.
4. Для каждого сегмента по порядку: проверить ограничения (все должны выполниться); построить распределение; вычислить bucket; проверить rollout; выбрать вариант по bucket; вернуть вариант и сегмент.
5. Если ни один сегмент не подошёл → вернуть «нет варианта».

## 7. Требования консистентности

Все клиенты должны использовать один и тот же вход хеша (`salt + entityID`), один и тот же CRC32 и формулу bucket, один и тот же порог rollout (`bucket < rolloutPercent * 10`) и одну и ту же накопленную схему распределения. Тогда один и тот же entityID всегда получает один и тот же вариант при одной и той же конфигурации флага/сегмента.

Полный текст спецификации: [English](evaluation-spec.md).
